"""
MLVM Compiler
"""

import re
import os
import sys
from mlvm.const import *
from mlvm.processor import MLVMProcessor
from mlvm.instructions import instruction_from_name
from mlvm.bus import MLVMBus

# Virtual registers for inverse
INVERSE_REGISTERS = {
    "A": "X",
    "B": "Y",
    "C": "Z"
}

# Operators with only one operand
EXPRESSION_UNARY_OPERATORS = (
    "~"
)

# Order of operations, higher prededence to the right
EXPRESSION_OPERATOR_PRECEDENCE = (
    "&&", "==", ">=", "<=", ">", "<", "|", "^", "&", "<<", ">>", "+", "-", "*", "/", "%", "~"
)

# Mapping operators to their instruction
EXPRESSION_OPERATOR_INSTRUCTION_MAP = {
    "==": "CMP", ">=": "GTE", "<=": "LTE", ">": "GTC", "<": "LTC", "|": "IOR", "^": "XOR",
    "&": "AND", "<<": "LSS", ">>": "RSS", "+": "ADD", "-": "SUB", "*": "MUL", "~": "NOT",
    "&&": "ANL", "%": "MOD", "/": "DIV"
}

# List of all operators
OPERATORS = (
    "/*", "*/", "==", ">=", "<=", "=", ">>", "<<", ">", "<", "{", "}", "\"", "'", "+", "-", "*",
    "(", ")", "&&", "&", "|", "^", "~", "#", "@", "!", "?", ";", "%", "/"
)

# List of reserved keywords
KEYWORDS = [
    "fn", "define", "include", "var", "set", "if", "else",
    "while", "halt", "asm", "begin", "return", "call"
]

VALUE_RE = "(0x[0-9A-Fa-f]+|0b[01]+|-?[0-9]+)"
SYMBOL_RE = "[a-zA-Z\_]+[a-zA-Z0-9\_]*"
WHITESPACE_RE = "[ \n]+"

class CompilerStateMachine():
    STATE_NONE = 0
    STATE_COMMENT = 1
    STATE_DEFINE = 2
    STATE_VAR = 3
    STATE_FUNCTION_NAME = 4
    STATE_ASM = 5
    STATE_BRACE_CONTENT = 6
    STATE_SET_LHS = 7
    STATE_SET_RHS = 8
    STATE_CALL = 9
    STATE_IF = 10
    STATE_LOOP = 11
    STATE_INCLUDE = 12

    ASM_ELEMENT_TYPE_INSTRUCTION = 1
    ASM_ELEMENT_TYPE_POINTER = 2

    SET_TYPE_SYMBOL = 1
    SET_TYPE_ADDR = 2

    def __init__(self, mlvc_filename, cwd):
        try:
            with open(mlvc_filename, "r") as mlvc_file:        
                self.program_text = mlvc_file.read()
        except:
            print(f"Failed to open {input_file}!")
            exit(1)

        self.tokens = self.string_to_tokens(self.program_text)
        self.asm = ""
        self.conditional_stack = []
        self.loop_stack = []
        self.state_stack = [self.STATE_NONE]
        self.defines = {}
        self.static_vars = {}
        self.function_names = {}
        self.brace_level = 0
        self.current_prog_mem_addr = PROG_MEM_START_ADDR
        self.cur_conditional_id = 0
        self.cur_loop_id = 0
        self.cur_line = 1
        self.cur_file = mlvc_filename
        self.cwd = cwd

        self.define_builder_content = []
        self.define_builder_name = None

        self.function_builder_name = None

        self.asm_block_brace_state = False
        self.asm_block_element_type = None

        self.expression_builder = []

    def string_to_tokens(self, file):
        # Convert a string into a list of tokens

        # Create a regex to split operators
        lexer_regex_s = "( |\\n"

        for operator in OPERATORS:
            operator = '\\' + ('\\'.join(list(operator)))
            lexer_regex_s += f"|{operator}"

        lexer_regex_s += ")"

        tokens = re.split(lexer_regex_s, file)
        tokens = [token for token in tokens if token != ""] # Remove empty tokens

        return tokens

    def generate(self):
        # Header
        self.asm += "/* Generated by MLVC Compiler */\n\n"
        self.asm += f".offset {hex(ROM_START)}\n"
        self.asm += f".offset {hex(ROM_SIZE)}\n\n"
        self.asm += f"JMI $mlvc_program_start\n\n"

        # Iterate through each token and process
        for token in self.tokens:
            self.process(token)

        return self.asm

    def syntax_error(self, msg):
        print(f"SYNTAX ERROR IN {self.cur_file} ON LINE {self.cur_line}: {msg}")
        exit(1)

    def memory_error(self, msg):
        print(f"MEMORY ERROR: {msg}")
        exit(2)

    def include_file(self, filename):
        # Store current line and file and reset it for the new file
        old_cur_line = self.cur_line
        old_cur_file = self.cur_file
        self.cur_line = 1
        self.cur_file = os.path.join(self.cwd, f"{filename}.mlvc")

        with open(self.cur_file, "r") as include_file:
            self.asm += f"\n/* Begin MLVC include {filename} */\n"
            include_file_text = include_file.read()
            include_file_tokens = self.string_to_tokens(include_file_text)
            self.state_stack.append(self.STATE_NONE)

            for token in include_file_tokens:
                self.process(token)
            
            self.asm += f"\n/* End MLVC include {filename} */\n\n"

        # Load current line and file of parent file of the include
        self.cur_line = old_cur_line
        self.cur_file = old_cur_file

    def process_keyword(self, token):
        # We ran into a keyword, set up the state machine to begin processing it
        if token == "define": # Preprocessor defines, start reading tokens for replacement until semicolon
            self.state_stack.append(self.STATE_DEFINE)
            self.define_builder_content = []
            self.define_builder_name = None
        
        elif token == "include": # Include file, immediately start processing it
            self.state_stack.append(self.STATE_INCLUDE)

        elif token == "var": # Allocate a variable into program memory
            self.state_stack.append(self.STATE_VAR)
        
        elif token == "begin": # Notate where the program begins
            self.asm += "\nmlvc_program_start:\n"
        
        elif token == "fn": # Define a function
            if self.STATE_FUNCTION_NAME in self.state_stack:
                self.syntax_error("Cannot nest function definitions!")

            self.state_stack.append(self.STATE_FUNCTION_NAME)
        
        elif token == "return": # Return from a function
            self.append_instruction("RET")
        
        elif token == "asm": # Assembly block, place instructions inline
            if self.state == self.STATE_ASM:
                self.syntax_error("Cannot nest asm blocks!")

            self.state_stack.append(self.STATE_ASM)
            self.asm_block_brace_state = False
        
        elif token == "set": # Variable assignment
            self.state_stack.append(self.STATE_SET_LHS)
            self.set_type = None
            self.set_dest = None
        
        elif token == "call": # Calling functions
            self.state_stack.append(self.STATE_CALL)

        elif token == "if": # Conditional
            self.state_stack.append(self.STATE_IF)
            self.expression_builder = []
        
        elif token == "while": # Loop
            self.state_stack.append(self.STATE_LOOP)
            self.expression_builder = []

    def process(self, token):
        # The main state machine tick function
        self.state = self.state_stack[-1]

        if token == "\n":
            self.cur_line += 1

        if self.state == self.STATE_COMMENT: # While were in a comment just wait for the close comment operator, otherwise do nothing
            if token == "*/":
                self.state_stack.pop(-1)

        elif token == "/*": # Enter a comment
            self.state_stack.append(self.STATE_COMMENT)

        elif token in self.defines: # We found a preprocessor define so just process the tokens of the value of that define inline here
            for dtoken in self.defines[token]:
                self.process(dtoken)

        elif self.state == self.STATE_DEFINE: # We are currently defining a preprocessor define
            if token == ";": # The end of the value
                if self.define_builder_name is None:
                    self.syntax_error("Empty define!")

                self.state_stack.pop(-1)
                self.defines[self.define_builder_name] = self.define_builder_content

            else:
                if self.define_builder_name is None: # We haven't reached the name yet, wait to see it
                    if re.match(SYMBOL_RE, token):
                        self.define_builder_name = token
                    else:
                        if not re.match(WHITESPACE_RE, token):
                            self.syntax_error("Malformed define name!")

                else: # We are currently in the content of the define, append tokens until semicolon
                    self.define_builder_content.append(token)
        
        elif re.match(WHITESPACE_RE, token): # Ignore whitespace
            pass
            
        elif self.state == self.STATE_INCLUDE: # We are currently in an include block, wait for file name
            if not re.match(SYMBOL_RE, token):
                if token == ";":
                    self.state_stack.pop(-1)
                else:
                    self.syntax_error("Malformed module name!")
            else:
                self.include_file(token) # We got a file name so include it

        elif self.state == self.STATE_VAR: # We are defining variables, allocate each token as a variable symbol until semicolon
            if not re.match(SYMBOL_RE, token):
                if token == ";":
                    self.state_stack.pop(-1)
                else:
                    self.syntax_error("Malformed var name!")
            else:
                self.allocate_static_var(token, 1)

        elif self.state == self.STATE_FUNCTION_NAME: # We are defining a function
            if self.function_builder_name is None: # We haven't defined the name yet so wait for that
                if not re.match(SYMBOL_RE, token):
                    self.syntax_error("Malformed function name!")
                else:
                    self.allocate_function(token)
                    self.function_builder_name = token
            else: # We have defined the name so wait for the opening brace
                if token != "{":
                    self.syntax_error("Did not open function content!")
                else:
                    self.state_stack.append(self.STATE_BRACE_CONTENT) # We found an opening brace so move to the brace content state
        
        elif self.state == self.STATE_ASM: # We are in an assembly block
            if self.asm_block_brace_state: # We are in the content of the assembly block
                if token == "{":
                    self.syntax_error("Cannot use braces inside asm block!")
                elif token == "}": # End of assembly block
                    self.asm += "    /* End MLVC asm block */\n"
                    self.asm_block_brace_state = False
                    self.state_stack.pop(-1)
                else:
                    if self.asm_block_element_type is not None: # We saw an operator last token that hints at the type of the next token
                        if self.asm_block_element_type == self.ASM_ELEMENT_TYPE_INSTRUCTION: # Process token as an instruction
                            self.append_instruction(token)
                        elif self.asm_block_element_type == self.ASM_ELEMENT_TYPE_POINTER: # Process token as a pointer
                            if token in self.static_vars:
                                self.append_instruction(f"${self.asm_prefix_var(token)}")
                            else:
                                self.syntax_error(f"Variable not defined: {token}!")

                        self.asm_block_element_type = None

                    else:
                        if token == "#": # Instruction indicator
                            self.asm_block_element_type = self.ASM_ELEMENT_TYPE_INSTRUCTION # Next token should be an instruction
                        elif token == "@": # Pointer indicator
                            self.asm_block_element_type = self.ASM_ELEMENT_TYPE_POINTER # Next token should be a symbol
                        elif re.match(VALUE_RE, token): # Otherwise just treat the token as a literal
                            self.append_instruction(token)

            elif token == "{": # We haven't found the opening brace yet so wait for that, and then open the block
                self.asm += "    /* Begin MLVC asm block */\n"
                self.asm_block_brace_state = True

        elif self.state == self.STATE_SET_LHS: # We are in the left hand side of a set block
            if re.match(SYMBOL_RE, token):
                # We found a symbol so check to make sure that symbol exists
                self.set_type = self.SET_TYPE_SYMBOL
                if token in self.static_vars:
                    self.set_dest = token
                else:
                    self.syntax_error(f"Undefined symbol: {token}!")

            elif re.match(VALUE_RE, token):
                # We found a value so we are writing directly to a memory address
                self.set_type = self.SET_TYPE_ADDR
                self.set_dest = token
            
            elif token == "=":
                # Move to the right hand side after the = operator
                if self.set_type is None:
                    self.syntax_error("No left hand side in set!")

                self.state_stack.pop(-1)
                self.state_stack.append(self.STATE_SET_RHS)
                self.expression_builder = []
            
            else:
                self.syntax_error("Malformed left hand side of set!")
        
        elif self.state == self.STATE_SET_RHS: # We are in the right hand side of a set block, start building expression
            if token == ';': # End of expression, solve it
                output_register = self.solve_expression(self.expression_builder)

                # After the instruction is solved, actually write the result to the variable/address
                if self.set_type == self.SET_TYPE_ADDR:
                    self.append_instruction(f"LND {self.set_dest} WR{output_register}")
                elif self.set_type == self.SET_TYPE_SYMBOL:
                    self.append_instruction(f"LND ${self.asm_prefix_var(self.set_dest)} WR{output_register}")
                else:
                    self.syntax_error("Unknown problem in set!")

                self.state_stack.pop(-1)

            else: # We are still building the expression until a semicolon so append tokens to the expression until then
                self.expression_builder.append(token)

        elif self.state == self.STATE_CALL: # We are in a function call block
            if token == ";":
                self.state_stack.pop(-1)
            elif re.match(SYMBOL_RE, token): # Look for the name of the function then call it
                self.function_call(token)
            else:
                self.syntax_error(f"Invalid function name: {token}!")

        elif self.state == self.STATE_IF: # We are in an if block
            if token == "{": # Opening brace so we are in the content
                self.conditional_stack.append(self.cur_conditional_id)
                self.asm += "    /* MLVC if expression */\n"
                output_register = self.solve_expression(self.expression_builder) # Evaluate the expression
                # Jump to the else label of the if statement if the expression evaluates as false
                self.asm += f"    J{INVERSE_REGISTERS[output_register]}I $conditional_{self.cur_conditional_id}_else /* MLVC if conditional */\n"
                self.cur_conditional_id += 1
                self.state_stack.append(self.STATE_BRACE_CONTENT)

            else: # We haven't reached the opening brace yet so we're still building the conditional expression
                self.expression_builder.append(token)

        elif self.state == self.STATE_LOOP: # We are in a loop block
            if token == "{": # Opening brace so we are in the content
                self.loop_stack.append(self.cur_loop_id)
                self.asm += f"loop_{self.cur_loop_id}_begin: /* Begin MLVC while block */\n" # Opening label to jump to at end
                self.asm += "    /* MLVC if expression */\n"
                output_register = self.solve_expression(self.expression_builder) # Conditional expression
                # Jump to after the end of the loop if the expression evaluates as false
                self.asm += f"    J{INVERSE_REGISTERS[output_register]}I $loop_{self.cur_loop_id}_end /* MLVC while conditional */\n"
                self.cur_loop_id += 1
                self.state_stack.append(self.STATE_BRACE_CONTENT)

            else: # We haven't reached the opening brace yet so we're still building the conditional expression
                self.expression_builder.append(token)

        else:
            if token in KEYWORDS: # We found a keyword so process it to set up the state for it
                self.process_keyword(token)
            
            elif token in OPERATORS: # Operators not in expressions
                if token == "{": # Opening brace so append new brace content to state stack
                    self.state_stack.append(self.STATE_BRACE_CONTENT)
                elif token == "}": # We found a closing brace, so we need to figure out what the previous keyword was before the open brace and clean up
                    self.state_stack.pop(-1)

                    if self.state_stack[-1] == self.STATE_FUNCTION_NAME: # We are closing a function so add a return always
                        self.state_stack.pop(-1)
                        self.function_builder_name = None
                        self.append_instruction("RET")
                        self.asm += "\n"
                    
                    elif self.state_stack[-1] == self.STATE_IF: # We are closing an if statement so add the else label to jump do if the conditional is false
                        self.state_stack.pop(-1)
                        conditional_id = self.conditional_stack.pop(-1)
                        self.asm += f"conditional_{conditional_id}_else: /* End MLVC if statement */\n"

                    elif self.state_stack[-1] == self.STATE_LOOP: # We are closing a loop statement so add a jump to the beginning and a label for jumping out of the loop
                        self.state_stack.pop(-1)
                        loop_id = self.loop_stack.pop(-1)
                        self.append_instruction(f"JMI $loop_{loop_id}_begin")
                        self.asm += f"loop_{loop_id}_end: /* End MLVC while block */\n"

            elif re.match(VALUE_RE, token): # We matched a literal out of context, syntax error
                self.syntax_error(f"Unexpected literal: {token}")
            
            elif re.match(SYMBOL_RE, token): # We matched a symbol out of context, syntax error
                self.syntax_error(f"Unexpected symbol: {token}")
            
            else: # No clue what this token is supposed to be so syntax error
                self.syntax_error(f"Illegal token: {token}")

    def asm_prefix_var(self, varname):
        # Convert var name to assembler var name
        return f"mlvc_static_var_{varname}"
    
    def asm_prefix_function(self, fname):
        # Convert function name to assembler label
        return f"mlvc_function_{fname}"

    def allocate_static_var(self, varname, size):
        # Allocate static var in program memory
        if self.current_prog_mem_addr == PROG_MEM_END_ADDR:
            self.memory_error("Out of program memory!")

        if varname in KEYWORDS: # Don't allow variable names to be keywords
            self.syntax_error(f"{varname} is a reserved keyword!")

        if varname in self.static_vars or varname in self.function_names: # Don't allow duplicate symbol names
            self.syntax_error(f"Symbol {varname} previously defined!")

        self.static_vars[varname] = self.current_prog_mem_addr
        self.current_prog_mem_addr += size

        # We'll just let the assembler handle the symbol, and the compiler handle the static memory allocation
        self.asm += f".set {self.asm_prefix_var(varname)} {hex(self.static_vars[varname])}\n"

    def allocate_function(self, fname):
        # Create a label for a function

        # No keywords
        if fname in KEYWORDS:
            self.syntax_error(f"{fname} is a reserved keyword!")
        
        # No duplicates
        if fname in self.static_vars or fname in self.function_names:
            self.syntax_error(f"Symbol {fname} previously defined!")
        
        self.function_names[fname] = self.asm_prefix_function(fname)

        # Create the label for the function because we'll immediately start appending its content
        self.asm += f"\n/* MLVC function {fname} */\n"
        self.asm += f"{self.function_names[fname]}:\n"
    
    def append_instruction(self, instruction):
        self.asm += f"    {instruction}\n"

    def infix_to_rpn(self, expression):
        """
        Convert an infix expression to RPN using operator precedence and parentheses
        """
        
        output = []
        stack = []

        for token in expression:
            if token in EXPRESSION_OPERATOR_PRECEDENCE:
                while len(stack) and stack[-1] != "(" and stack[-1] in EXPRESSION_OPERATOR_PRECEDENCE and EXPRESSION_OPERATOR_PRECEDENCE.index(token) <= EXPRESSION_OPERATOR_PRECEDENCE.index(stack[-1]):
                    output.append(stack.pop())
                stack.append(token)
            
            elif token == "(":
                stack.append("(")

            elif token == ")":
                while len(stack) and stack[-1] != "(":
                    output.append(stack.pop())
                
                if stack.pop() != "(":
                    self.syntax_error("Mismatched parentheses!")

            else:
                output.append(token)

        while len(stack):
            if stack[-1] == "(" or stack[-1] == ")":
                self.syntax_error("Mismatched parentheses!")

            output.append(stack.pop())

        return output

    def evalute_const_operation(self, a, b, instruction):
        """
        Constant folding, set up a virtual processor at compile time
        """

        temp_cpu = MLVMProcessor(MLVMBus())
        temp_cpu.cur_instruction = instruction
        temp_cpu.cur_step = 0
        temp_cpu.reg_a = a
        temp_cpu.reg_b = b

        # Run the virtual processor until the operation completes
        for i in range(len(instruction)):
            temp_cpu.clock_neg()
            temp_cpu.clock_pos()

        # Return the solution from the processor
        return temp_cpu.reg_c

    def solve_expression(self, expression):
        """
        Recursively solve an expression, return the register the answer ends up in
        """
        
        if len(expression) == 0:
            self.syntax_error("Cannot solve empty expression!")

        rpn = self.infix_to_rpn(expression.copy()) # Conver the expression to RPN
        output_register = None

        stack = [] # Compiler stack

        def get_element(e, reg):
            if e is None: # Element is on the system stack so pull it from there
                self.append_instruction(f"PUL S{reg}C")

            elif re.match(VALUE_RE, e): # Element is a literal, express it
                self.append_instruction(f"LN{reg} {e}")

            elif re.match(SYMBOL_RE, e): # Element is a symbol, load it
                if not e in self.static_vars:
                    self.syntax_error(f"Undefined symbol: {e}!")

                self.append_instruction(f"LND ${self.asm_prefix_var(e)} RD{reg}")

            else:
                self.syntax_error("Bad expression!")

        for i, element in enumerate(rpn):
            if element in EXPRESSION_OPERATOR_PRECEDENCE:
                b = stack.pop()
                a = stack.pop()

                if a is not None and b is not None and re.match(VALUE_RE, a) and re.match(VALUE_RE, b):
                    # both are const, constant fold this operation
                    c = self.evalute_const_operation(int(a, 0), int(b, 0), instruction_from_name(EXPRESSION_OPERATOR_INSTRUCTION_MAP[element]))
                    stack.append(str(c))

                else: # otherwise evaluate it normally
                    # Get the two operands into the A and B registers
                    get_element(b, "B")
                    get_element(a, "A")

                    # Run the instruction
                    self.append_instruction(EXPRESSION_OPERATOR_INSTRUCTION_MAP[element])

                    if i == (len(rpn) - 1): # We are at the end of our expression so the answer is in the C register
                        output_register = "C"
                    else: # We have more expression to evaluate so push this subproblem answer to the system stack
                        self.append_instruction("PSH")
                        stack.append(None) # Pushed onto real stack, pull off later
            else:
                stack.append(element) # Push operand to the compiler stack

        if len(stack): # The stack has one element left so we load it into the A register as the answer
            get_element(stack.pop(), "A")
            output_register = "A"

        return output_register

    def function_call(self, fname):
        # Subroutine calls
        self.asm += f"    LND ${self.asm_prefix_function(fname)} SRT /* Calling MLVC function {fname} */\n"


if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("You must specify an input and output file!")
        exit(1)

    input_file = sys.argv[1]
    output_file = sys.argv[2]

    cwd = os.path.join(*os.path.split(input_file)[:-1]) # Get the current working directory
    csm = CompilerStateMachine(input_file, cwd)
    asm = csm.generate() # Generate the assembly

    print(asm)

    # Output to output file
    try:
        with open(output_file, "w") as output_stream:
            output_stream.write(asm)
    except:
        print(f"Failed to open {output_file}!")
        exit(1)
